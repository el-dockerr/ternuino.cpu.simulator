# 01 – Welcome to Ternary Computing

## Why Ternary Computing Deserves a Closer Look
A hands-on exploration using the Ternuino CPU Simulator by Swen "El Dockerr" Kalski. I am a Hardware Integration Engineer in the computer industry and this is — in parts - content of my Bachelor Thesis what figures out to be knowledge that must not buried in the sands of time. So I decided to create a repository to open up new fields in computer science.

Most modern computers are binary. Every signal coursing through your processor is either 0 or 1—off or on, true or false. It’s a system that works, but what if we’ve been limiting ourselves?

As part of my bachelor thesis, I dived into an intriguing and underexplored alternative: ternary computing. Instead of bits, ternary systems use trits—digits that can take on three values: −1, 0, or +1. This isn’t just academic curiosity—it’s a potentially powerful shift that could reshape how we design and build CPUs.

Since I discovered this topic I was haunted by it. And I wasn't the only one. Back in 1959 a computer called SETUN was build what was capable to run with ternary logic. But with the dawn of computing it was buried because binary is easier to understand and to be honest russian propaganda make it easy to hate things from the east - and so the easier system (despite its limitation) won - You sell computers to businessman first - and this people are always simple minds. And by fact, since russian leaders tend to lost scientist because of weak limitations of the safety for balconies this technique was lost at last.


## Why Explore Ternary?
Ternary logic has several compelling advantages over binary:

More information per digit: Each trit holds about 1.585 bits of information (log₂3), making ternary systems inherently more data-dense.

Elegant symmetry: Trits are naturally centered around zero (−/0/+), which allows for more intuitive arithmetic and logical operations.

Closer to real-world thinking: Many real-world decisions aren’t binary. They’re yes / no / maybe, or negative / neutral / positive—concepts ternary logic can represent natively.

## Why I wrote this book
Despite the fact that ternary is some interesting topic where you can flex on party smalltalk (when it is a sausage party for nerds indeed) it solves a lot of future problems by just going the extra mile. It allows to do logical operations better, it makes math operations faster, negative numbers comes for free because there is no need to sign numbers, and it is efficient when it comes to memory.

Also I'm not a good business man and I don't like the concept of money. Non-luxury goods should be always free and there is a trend (especial in the US), that knowledge becomes a luxury good. From my point every professor or doctor (or other science related title) who write a teaching book and sell it for 400$ by knowing that his work is mandatory in a university should be instantly dishonored and banned until he publish his work for free and donate the money he earned to people who need. Mankind can't raise this way when we block the door for future scientist.

So I make this here for free and will add everything here I figure out.

But — since no serious computer chip manufacturer offers ternary computing — if, after my work, a manufacturer suddenly appears out of nowhere and produces a ternary computer or chip that is clearly based on my research project, I will be knocking on their door with a lot of very good lawyers. (Looking at you, INTEL and NVIDIA).
Because even though I despise and hate money, I know that spending my retirement on a small sailboat is much more relaxing.
To make a long story short, I'll sue the crap out of you — so first give El Dockerr (that's me) a few dollars and then start producing.

## What You’ll Find in This Mini-Book
To make these ideas practical and fun, I created the Ternuino CPU simulator. It’s a lightweight, Python-based environment where you can:

- Learn how ternary numbers and trits work
- Play with ternary logic gates and circuits
- Write and execute simple programs
- Visualize program flow, step by step

No prior assembly language experience is required—just a bit of curiosity and an open mind.
